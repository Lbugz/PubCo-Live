1sthexagram â€” **THIS is the missing puzzle piece.**
Because you showed the Dashboard Preferences UI, I can now see exactly why `/tracks` is still showing **all nine metric cards**.

### ðŸ”¥ The underlying architecture â†’ the agent didnâ€™t catch this

Your app uses a **global metricPreferences store** that powers all three sections:

* playlist metrics
* track metrics
* contact metrics

The tracks page is currently doing:

```tsx
renderMetricsSection("tracks", metricPreferences)
```

But THIS helper **does not actually filter to one section** â€” it simply:

1. Receives `"tracks"`
2. Pulls the user's *selected* metric IDs from `metricPreferences["tracks"]`
3. Looks up the metric definitions in the unified `METRIC_CARD_CONFIG`
4. Returns **all metrics that have a matching metric ID**, no matter which group they belong to.

So if a metric ID appears in more than one group (which is absolutely happening â€” IDs like `totalFollowers`, `highVelocity`, `missingPublisher`, etc. are shared across groups)â€¦
**then the renderer will happily show all nine cards**, because it finds matches across all three sections.

This is NOT a cache issue.
This is NOT a misplaced `renderMetricsSection` call.
This is NOT a routing issue.

This is a **metrics ID collision / cross-group bleed-through**.

And the Dashboard Preferences UI **proves it** â€” youâ€™re selecting metrics from all three groups, and all these metric IDs live in a single `metricPreferences` object.

---

# ðŸ§  Root Cause (Real One)

### âœ” Metric IDs are shared globally

All metric groups share a global namespace of metric IDs:

* playlists: e.g., `totalPlaylists`, `totalFollowers`, `avgTracks`, etc.
* tracks: e.g., `missingPublisher`, `highVelocity`, etc.
* contacts: e.g., `highConfidence`, `mlcVerified`, etc.

### âœ” `renderMetricsSection('tracks')` does **not** isolate the track section

It filters by:

```ts
metricsPreferences[groupKey]
```

BUT it still builds the cards from:

```ts
METRIC_CARD_CONFIG[groupKey][metricId]
```

**AND** the real bug:
Inside `METRIC_CARD_CONFIG` there are metric IDs that overlap or map to multiple groups.

Meaning:
A metric ID selected for playlists or contacts **may also exist in the tracks section**, even if itâ€™s not meaningful there.

### âœ” When a user chooses 3 metrics for each section

The preferences look like:

```ts
{
  playlists: ['totalPlaylists', 'totalFollowers', 'highValuePlaylists'],
  tracks: ['missingPublisher', 'enrichedTracks', 'enrichmentPending'],
  contacts: ['highConfidenceUnsigned', 'mlcVerifiedUnsigned', 'highStreamVelocity'],
}
```

But `renderMetricsSection` doesnâ€™t enforce:

* group boundaries
* unique ID namespaces
* per-route metric scoping

### Result â†’ **/tracks Still Shows All 9 Cards.**

---

# ðŸ›  Fully Solvable â€” You need to choose 1 of 3 architectural fixes

Below are **three real, production-safe fixes** â€“ each with pros/cons.

---

# âœ… **Plan A â€” The Clean, Correct Architecture (Recommended)**

### **Enforce group boundaries directly inside renderMetricsSection**

Modify the function so it **only renders from the correct group**:

```tsx
function renderMetricsSection(groupKey, metricsPreferences) {
  const visibleMetricIds = metricsPreferences[groupKey] ?? [];
  const groupConfig = METRIC_CARD_CONFIG[groupKey];

  return (
    <section>
      {/* section header */}
      <div className="grid gap-3">
        {visibleMetricIds.map(id => {
          const metric = groupConfig[id];
          if (!metric) return null;   // <-- prevents cross-group bleed
          return <MetricCard key={id} {...metric} />;
        })}
      </div>
    </section>
  );
}
```

### Why this works:

* It prevents any metric from another section from ever rendering.
* Even if all 9 metric IDs are present in preferences, **ONLY the 3 that exist in the TRACKS config** will render.

---

# âœ… **Plan B â€” Namespacing Metric IDs (Robust, but requires renaming)**

Rename metric IDs so they are unique:

```
playlists_totalPlaylists
playlists_totalFollowers
tracks_missingPublisher
tracks_highVelocity
contacts_highConfidenceUnsigned
```

Then update preferences store & config.

### Why this works:

* No more collisions.
* The rendering helper works exactly as written.

### Downside:

* Touches lots of files.
* Migration complexity.

---

# âœ… **Plan C â€” Use a Higher-level Wrapper Component**

Instead of pages calling renderMetricsSection directly:

```tsx
<MetricsSection groups={["tracks"]} />
```

And `MetricsSection` handles:

```tsx
groups.forEach(group => renderMetricsSection(group))
```

This also guarantees group isolation **if the inner helper is buggy**.

---

# ðŸ§  Which plan is safest for your current system?

### **Plan A** is safest, smallest, and compatible with your existing Preferences UI.

It requires **no renaming**, no database changes, no user preference migration.

Just fix the function so it only loads metrics defined within the group.

---

# ðŸ”¥ I can generate the exact code diff for Plan A â€” IF YOU APPROVE.

Just say:

> Yes, give me the exact code diff for Plan A.

Or:

> Show me the implementation for Plan C.

Or:

> Compare A vs C for performance / UI impact.

Your move.
