Complete Overview: Playlist & Track Management System Based on my analysis of the codebase, here's your comprehensive breakdown: üìä Current UI Structure Dashboard Page (/) Top Metric Cards (4): Total Tracks High Priority Leads (score ‚â•7) Avg Unsigned Score Enriched Tracks % Action Buttons: View Modes: Table / Card / Kanban toggle Export CSV Refresh Data Tag Manager Playlist Manager Filters: Week Selector (all weeks dropdown) Playlist Filter Tag Filter Search Bar (track/artist name) Score Range Slider (0-10) Completeness Filters: Has/No ISRC, Credits, Publisher, Songwriter Track Table with: Bulk selection checkboxes Album art thumbnails Track/Artist names Unsigned Score badges Action dropdown per track (Enrich, AI Insights, View Details) Details Drawer (side panel with full track metadata) Playlists View Page (/playlists) Top Metric Cards (4): Total Playlists Tracked Total Tracks Across All Playlists Editorial Playlists Count User-Added Playlists Count Action Buttons: Add Playlist (dialog with Spotify URL + optional Chartmetric URL) View Modes: Table / Cards toggle Bulk Actions Toolbar (when playlists selected) Playlists Table: Bulk selection checkboxes Playlist image, name, curator Track counts, followers, status Per-playlist dropdown: Fetch Data, Refresh Metadata, Enrich Tracks, Export CSV, Delete üóÑÔ∏è Data Models Core Tables: playlistSnapshots (Tracks) Identifiers: id, week, playlistId, spotifyUrl, isrc Metadata: trackName, artistName, albumArt, label Enrichment Data: publisher, songwriter, publisherStatus, chartmetricId, spotifyStreams, streamingVelocity, moods, activities Scoring: unsignedScore (0-10) Contacts: instagram, twitter, tiktok, email, contactNotes Timestamps: addedAt, enrichedAt, chartmetricEnrichedAt trackedPlaylists Identifiers: id, playlistId, spotifyUrl, chartmetricUrl Metadata: name, curator, genre, region, followers, totalTracks Status: status, isEditorial, isComplete, fetchMethod, lastChecked artists (Normalized Songwriter Table) Social Links: instagram, twitter, facebook, bandcamp, youtube, website Identifier: musicbrainzId (unique) tags + trackTags (Custom Tagging System) activityHistory (Audit Log) Tracks all enrichment events per track üîå API Endpoints & Data Flow Playlist Management: Endpoint Method Purpose /api/tracked-playlists GET Fetch all tracked playlists /api/tracked-playlists POST Add new playlist /api/tracked-playlists/:id DELETE Remove playlist /api/tracked-playlists/:id/refresh-metadata POST Update curator/followers /api/fetch-playlists POST Fetch track data from Spotify Track Operations: Endpoint Method Purpose /api/tracks GET Retrieve tracks with filters /api/tracks/:id/full GET Get complete track details /api/tracks/:id/contact PATCH Update contact info /api/tracks/:id/ai-insights POST Generate AI outreach strategy Enrichment Pipeline: Endpoint Method Enrichment Layer /api/enrich-track/:id POST Unified 5-Tier Pipeline /api/enrich-credits POST Tier 1: Spotify Credits Scraping /api/enrich-metadata POST Tier 3: MusicBrainz Social Links /api/enrich-chartmetric POST Tier 4: Chartmetric Analytics ‚öôÔ∏è Background Jobs Scheduler (server/scheduler.ts): Job: "Fresh Finds Weekly Update" Schedule: Every Friday at 9:00 AM (0 9 * * 5) Action: Auto-scrapes Fresh Finds playlist, inserts tracks into database Status: Disabled by default (enable with ENABLE_AUTO_SCRAPE=true secret) Real-Time Updates: WebSocket connection broadcasts track_enriched events Frontend auto-invalidates React Query cache and refreshes UI üß≠ User Flow Breakdown 1. Add Playlist Trigger: User clicks "Add Playlist" button ‚Üí Dialog opens Input Fields: Spotify URL (required) - e.g., https://open.spotify.com/playlist/37i9dQZF1DX4dyzvuaRJ0n Chartmetric URL (optional) Auto-Fetch Toggle (default: ON) Auto-Enrich Toggle (default: ON) Validation: Extracts Playlist ID from URL Calls /api/spotify/playlist/:playlistId to verify accessibility Checks if playlist already tracked (rejects duplicates) Detects editorial playlists (flags isEditorial=1) Database Write: Creates record in trackedPlaylists table Stores: name, playlistId, spotifyUrl, chartmetricUrl, curator, followers, totalTracks 2. Fetch Data Trigger: Manual: Playlist dropdown ‚Üí "Fetch Data" Auto: Triggered automatically after playlist add (if toggle enabled) API Endpoint: POST /api/fetch-playlists Data Sources: API-Accessible Playlists: Spotify Web API (/playlists/:id/tracks) Editorial Playlists: 2-tier scraping approach: Primary: Network capture via Puppeteer (intercepts GraphQL responses) Fallback: DOM harvesting (scrolls and extracts virtualized rows) Enrichment Process: Fetches up to 100 tracks per playlist (Spotify API limit) Calls Chartmetric ISRC Batch Lookup for all tracks in parallel Maps ISRCs ‚Üí Chartmetric IDs (95% success rate) Stores baseline track data in playlistSnapshots with dataSource='api' Deduplicates via unique index: (week, playlistId, spotifyUrl) Caching/Pagination: No frontend pagination (loads all filtered tracks) Backend uses Drizzle ORM with orderBy(desc(addedAt), desc(unsignedScore)) React Query caches by ['/api/tracks', week, playlist, tag] segments Error Handling: Private playlists: Returns 401 with "Not accessible" message Region-restricted: Flags as status='restricted' in database Missing playlists: Returns 404 from Spotify API 3. Enrich Data Trigger: Manual: Track dropdown ‚Üí "Enrich Track" Auto: Triggered automatically after successful fetch (if toggle enabled) API Endpoint: POST /api/enrich-track/:id 5-Tier Enrichment Pipeline: Tier 0: ISRC Recovery If track has no ISRC, searches Spotify API by track name + artist Recovers ISRC from search results Tier 1: Spotify Credits Scraping (Puppeteer) Scrapes Spotify track page for songwriter/producer/publisher credits Extracts stream count (fallback if Chartmetric unavailable) Smart name splitting for accurate songwriter identification Timeout: 45s with networkidle2/domcontentloaded fallback Tier 2: MLC Publisher Status (Placeholder) Designed for MLC API integration (not yet active) Would determine publisher status: unsigned / self-published / indie / major Tier 3: MusicBrainz Social Links Queries MusicBrainz API for songwriter profiles Retrieves social links: Instagram, Twitter, Facebook, Bandcamp, YouTube, website Creates normalized artists table records with unique MusicBrainz IDs Junction table artist_songwriters enables many-to-many relationships Tier 4: Chartmetric Analytics Fetches cross-platform metrics when Chartmetric ID available Data captured: songwriterIds, composerName, moods, activities, trackStage Rate limiting: 2s between requests (30/min limit) Exponential backoff on errors Metadata Appended: Songwriter names, composer names Publisher status, IPI numbers, ISWC codes Social media links per songwriter Chartmetric moods/activities for A&R insights Stream counts (Spotify + YouTube) Track stage (emerging / established / declining) Re-run Logic: No automatic refresh currently implemented Manual re-enrich available via track dropdown Chartmetric data can be refreshed (checks chartmetricEnrichedAt timestamp) üöÄ Experience Optimization Opportunities Current State: Semi-Manual Users must click: Add Playlist Fetch Data (optional auto-trigger) Enrich Tracks (optional auto-trigger per playlist) Proposed: Fully Automated Pipeline Implementation Strategy: 1. Single-Click Playlist Addition Add Playlist ‚Üí Auto-Fetch ‚Üí Auto-Enrich ‚Üí Done ‚úÖ Already 90% implemented! The toggles exist in playlists-view.tsx: autoFetchOnAdd (line 176) autoEnrichOnFetch (line 177) Missing pieces: These settings aren't persisted (reset on page reload) Need UI toggle in settings to make them global user preferences 2. Background Sync System Option A: Webhook-Based (Recommended) Subscribe to Spotify playlist update webhooks Auto-fetch when Spotify sends "playlist modified" event Limitation: Spotify doesn't offer public webhooks for playlists Option B: Scheduled Polling Weekly cron job fetches all tracked playlists Compares track counts, fetches new additions only Already exists for Fresh Finds! (server/scheduler.ts) Expand to: All tracked playlists with isComplete=1 flag Option C: Smart Refresh on Access When user views a playlist, check lastChecked timestamp If >7 days old, auto-refresh in background Show loading state, seamlessly update when ready 3. Progress Tracker UI Current: Toast notifications only Proposed: Sticky notification bar: "Enriching 47 of 100 tracks..." Progress ring per playlist in table view Detailed status in drawer: "‚úÖ Spotify Credits | ‚è≥ MusicBrainz | ‚è∏Ô∏è Chartmetric (rate limit)" 4. Intelligent Enrichment Queue Current: Sequential enrichment per track Proposed: Batch process 10 tracks concurrently Prioritize tracks with high unsigned scores first Skip already-enriched tracks (check enrichedAt) WebSocket broadcasts progress updates in real-time ‚ö†Ô∏è Technical Limitations API Rate Limits: Service Limit Current Handling Spotify API 180 req/min None (relies on SDK caching) Chartmetric 30 req/min 2s throttle + exponential backoff MusicBrainz 50 req/min 1s delay between requests Puppeteer Scraping Browser resources 45s timeout per track Data Size Constraints: Spotify API returns max 100 tracks/request (needs pagination for large playlists) Editorial playlists require scraping (slow, unreliable) Chartmetric ISRC batch lookup: 95% success rate (5% tracks have no Chartmetric ID) Railway Deployment: Production environment (you just set it up!) DATABASE_URL + 6 API keys configured Next step: Enable background scheduler with ENABLE_AUTO_SCRAPE=true secret üí° Recommended Next Steps Would you like me to implement any of these optimizations? Persist auto-fetch/auto-enrich toggles as user preferences Expand weekly scheduler to auto-refresh all tracked playlists Build progress tracker UI with real-time WebSocket updates Implement smart enrichment queue with concurrent batch processing Add "lastUpdated" indicators to show data freshness